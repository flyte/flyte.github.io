{"pages":[{"url":"mqtt-camera-based-motion-tracking-for-home-assistant.html","text":"This blog post will demonstrate the process I use to add motion tracking to any IP camera (and also perhaps directly connected ones) using the free and open source software Motion , and publish the motion detection over the MQTT message bus for use by Home Assistant , or indeed anything else that may want to use it. Since I run my services with Docker , it utilises a Docker Image of my creation , but the configuration details still apply, regardless of how you run Motion. Background I have a handful of IP cameras connected to the network in my home. They are relatively cheap, low powered, sparsely featured devices which just about handle the capture and streaming of video using Motion JPEG. Home Assistant has no problem viewing the video feed from the devices, but in order to use the video in my automations, I needed a way of detecting motion. Thankfully, there's a great, lightweight, free and open source project called Motion which handles the detection of motion in video streams. The majority of the 'smart' devices in my home communicate over the MQTT message bus. This is very convenient and integrates very well with Home Assistant. I wanted to find a way to use Motion to detect motion on my IP cameras and publish the events on an MQTT topic. Most of the services running on my home server are within Docker containers. I wanted Motion to be no different so I created a Docker Image for it , specifically including an MQTT publish client. Camera Configuration All of the cameras I use serve Motion JPEG streams over HTTP. This method is not limited to this configuration, and will support any camera which is supported by Motion. This includes network cameras and also directly connected ones , although you'll need to pass the device through to the docker container. In order to receive a Motion JPEG stream from my cameras, I use the following URL: http://10.0.0.10/videostream.cgi?loginuse=admin&loginpas=mypassword You may be able to get the URL for your camera by viewing its web interface in your browser (Chrome in this case), right clicking on the video feed and choosing 'Copy image address'. Note that in my case, simply browsing to the above URL doesn't seem to work. The same URL does work within Home Assistant and Motion, however. Motion Configuration Motion requires the use of a configuration file, so in order to get this, use the following Docker command: docker run -ti --rm flyte/motion-mqtt config > motion.conf If you're not using Docker, then you should be able to find this file in /etc/motion or /usr/local/etc/motion . It may be called motion.conf or motion-dist.conf . Camera Setup To set up Motion to connect to your IP camera, edit the motion.conf file and perform the following actions: Comment out the videodevice /dev/video0 line Uncomment the netcam_url line and set it to the URL of your video camera. For example: netcam_url http://10.0.0.10/videostream.cgi?loginuse=admin&loginpas=mypassword Note, for my cameras I use the mjpeg:// 'protocol', as described in the Motion guide : netcam_url mjpeg://10.0.0.10/videostream.cgi?loginuse=admin&loginpas=mypassword Disable Picture and Video Capture Since we're only using Motion to detect motion and not to record the events, change the following two config values from 'on' to 'off': output_pictures off ffmpeg_output_movies off Event Length By default each event lasts for 60 seconds after the motion is no longer detected. This is too long for my liking, so adjust the amount of seconds with the event_gap configuration value: event_gap 5 MQTT Configuration Finally, in order to actually publish the events to an MQTT topic, you must set the on_event_start and on_event_end configuration values. For example: on_event_start mosquitto_pub -h test.mosquitto.org -u yourusername -P yourpassword -t \"cam/office/motion\" -m \"on\" on_event_end mosquitto_pub -h test.mosquitto.org -u yourusername -P yourpassword -t \"cam/office/motion\" -m \"off\" If you're not using my Docker image, then you should be able to get the mosquitto_pub tool from the mosquitto-clients package. apt-get install mosquitto-clients if you're using Ubuntu/Debian/Raspbian. Have a look at mosquitto_pub --help for more usage information. Run the Service For my Docker containers, I tend to create a docker directory, then organise the files for each of the containers within subdirectories. For example, my three cameras are organised as such: motion-mqtt ├── office │ ├── config │ │ └── motion.conf │ └── run.sh ├── server_room │ ├── config │ │ └── motion.conf │ └── run.sh └── workshop ├── config │ └── motion.conf └── run.sh Each of the run.sh files contains the command I use to run each container: docker run -d \\ --name motion-mqtt-office \\ -v /home/flyte/docker/motion-mqtt/office/config:/motion:ro \\ flyte/motion-mqtt Note that the Motion configuration file is within a config directory which is shared within the Docker container as a volume at /motion . By default, the container will look for a configuration file at /motion/motion.conf . Once you've created a directory structure and created a run.sh script, make the script runnable with chmod +x run.sh and then execute it with ./run.sh . This should now have created a new Docker container. You can check the logs with docker logs -f motion-mqtt-office . If everything's gone well, you should now be able to wave at the camera and receive log entries along the line of the following: [1:ml1] [NTC] [ALL] motion_init: Started motion-stream server on port 8081 (auth Disabled) [1:ml1] [NTC] [EVT] event_new_video: Source FPS 2 [1:ml1] [NTC] [ALL] motion_detected: Motion detected - starting event 1 [1:ml1] [NTC] [ALL] mlp_actions: End of event 1 [1:ml1] [NTC] [EVT] event_new_video: Source FPS 2 [1:ml1] [NTC] [ALL] motion_detected: Motion detected - starting event 2 [1:ml1] [NTC] [ALL] mlp_actions: End of event 2 [1:ml1] [NTC] [EVT] event_new_video: Source FPS 2 [1:ml1] [NTC] [ALL] motion_detected: Motion detected - starting event 3 [1:ml1] [NTC] [ALL] mlp_actions: End of event 3 Use your favourite MQTT subscription tool (MQTT Lens or mosquitto_sub in my case) to check that you're publishing events to MQTT properly. Home Assistant Configuration To add the new motion sensor to Home Assistant, create a new Binary Sensor: binary_sensor : - name : Office Motion platform : mqtt state_topic : home/office/motion payload_on : \"on\" payload_off : \"off\" You may also want to set its device_class as motion so that the UI makes more sense: homeassistant : customize : binary_sensor.office_motion : device_class : motion This should now be enough to view the motion sensor state in Home Assistant. You may now want to set up automations using the input of the motion sensor, in which case I recommend you start with Automating Home Assistant .","tags":"Blog","title":"MQTT Camera Based Motion Tracking for Home Assistant"},{"url":"ministry-of-recycled-sound.html","text":"An advert for the latest Ministry of Sound album came on TV the other day. As usual, they played samples of some of the tunes you'll get on the album - one of which was Darude - Sandstorm . It occurred to me that all of the Ministry of Sound albums I can remember watching adverts for contained this one track. This made me wonder how many other songs kept getting put on the MoS albums repeatedly. What I wanted to see was a list of tracks sorted by how many times they had appeared on a Ministry of Sound album. I had a hunch that Sandstorm would be at the top. Fetch the database FreeDB is a license-free database for use in looking up track listings for CDs. We start by downloading the whole database (roughly 800MB bzipped file) and extracting its contents to the filesystem: tar xjvf freedb-complete-20140101.tar.bz2 Producing the following file structure: . ├── blues │ ├── 0008a512 │ ├── 000a8112 │ ├── 000a9612 <snip> ├── classical │ ├── 00073614 │ ├── 00088112 │ ├── 00092526 <snip> ├── country etc. Each file ( 000a9612 , 00073614 etc.) represents a single CD and they're organised into genre directories. The files contain, among other things, the track listing of the CD. Search for Ministry of Sound CDs Since there are over three million CDs listed in FreeDB, the files needed paring down a little. grep -ir \"ministry of sound\" . | perl -n -e '/(&#94;.+?):/ && print $1.\"\\n\"' | uniq > ministry.txt This grep command searches recursively and case-insensitively for the exact string \"ministry of sound\". It will normally output something like ./blues/4512b117:DTITLE=Various Artists / Ministry of Sound: Sessions Ten but all we care about is the file name (4512b117) so we use perl regex to capture and print it with a newline appended. This will produce duplicate file names, so we pipe it to uniq and finally output to a file called ministry.txt. This command took a long time to complete, but would have been a whole lot slower had we have done it using Python. Now we have a list of Ministry of Sound CDs, we copy the files into their own directory since we don't care what genre they're listed as. mkdir ministry cat ministry.txt | xargs -I {} cp {} ministry/ We now have all of the CD files in one directory so we can move on to using Python to figure out the answer to our question. Parse the CD files The first issue we need to solve is that some of the track names are too long to fit on a single line in the CD file. TTITLE13=David Morales and Larent Garnier / Ministry of Sound Dance Pa TTITLE13=rty Fragment We create a function which parses each line of the CD file and creates a dictionary of the keys and values. If a key is already in the dictionary, it will concatenate the value onto it. def parse_cd ( filename , replacements = {}): \"\"\" Takes the path to a FreeDB CD file and parses all key/value pairs into a dictionary. \"\"\" lines = {} with open ( filename , \"r\" ) as f : for line in f . readlines (): # Remove newline chars line = line . rstrip () # Ignore any comments or lines without an equals in if \"=\" not in line or line . startswith ( \"#\" ): continue # Extract the keys and values, forcing the values to be # lower case eq_index = line . index ( \"=\" ) key = line [: eq_index ] value = line [ eq_index + 1 :] . lower () # Take a dictionary of strings to search and replace eg. # {\" (original mix)\": \"\", \" - \": \" / \"} for old , new in replacements . items (): value = value . replace ( old , new ) # Check for the existence of a partial line in the # dictionary first and then append the rest of the # value if it exists. if key in lines : lines [ key ] += value else : lines [ key ] = value return lines Within this function we also replace certain characters and strings. Some of the delimiters are inconsistent in FreeDB, so we make an effort to replace them all with / . We also remove any occurrences of (original mix) since these are indeed the original tracks. REPLACEMENTS = { \" (original mix)\" : \"\" , \" - \" : \" / \" , \"-\" : \" / \" , \" / \" : \"/\" } We create a REPLACEMENTS constant to put at the top of our script and pass it to the parse_cd function at runtime. Count up the tracks We now have all the tools we need to count up the tracks. if __name__ == \"__main__\" : tracks_count = {} for filename in os . listdir ( DB_DIR ): # Parse the CD cd = parse_cd ( os . path . join ( DB_DIR , filename ), REPLACEMENTS ) # Extract the tracks tracks = [ cd [ x ] for x in cd . keys () if x . startswith ( \"TTITLE\" )] for track in tracks : # If the track has appeared already, increment its counter # otherwise add it and start it off at 1. if track in tracks_count : tracks_count [ track ] += 1 else : tracks_count [ track ] = 1 # Finally, sort the tracks_count dictionary by amount of appearances for track_count in sorted ( tracks_count . items (), key = lambda x : x [ 1 ]): print \" %s : %s \" % track_count We create a tracks_count dictionary to store the amount of appearances of each track. Next, we list the directory which contains all of the CD files and parse the files. We grab the tracks (the key always starts with TTITLE ) and either increment an existing entry in tracks_count or set it to 1 if it is its first appearance on a CD. Finally, we sort the tracks_count dictionary incrementally so that the most common track appears last on our console output and then print the whole lot. The Results ~/workspace/ministry $ python ministry.py | tail -n 30 iio/rapture: 9 atb/9pm (till i come): 9 deepest blue/give it away: 9 armand van helden/mymymy: 10 tomcraft/loneliness: 10 underworld/born slippy: 10 shakedown/at night: 10 supermode/tell me why: 10 double 99/rip groove: 10 yves larock/rise up: 10 jakatta/american dream: 10 alter ego/rocker: 10 jaydee/plastic dreams: 10 switch/a bit patchy: 10 kings of tomorrow/finally: 10 junior jack/stupidisco: 11 static revenger/happy people: 11 strike/u sure do: 11 paul johnson/get get down: 11 fedde le grand/put your hands up for detroit: 12 ministry of sound / the annual 2005 disc #2: 12 public domain/operation blade: 12 dee dee/forever: 13 eric prydz/call on me: 14 chill out session / disc 2: 14 storm/time to burn: 16 paffendorf/be cool: 16 mylo/drop the pressure: 16 roger sanchez/another chance: 21 darude/sandstorm: 25 The top 30 most common tracks used on Ministry of Sound CD releases. Look who's sitting pretty with 25 appearances! I must admit, I thought these tracks would show up more regularly, considering the amount of CD files we were searching through (1,229), but I'm happy that at least my prediction was correct. Next time you see an advert for a MoS album keep an ear out for Darude - Sandstorm ! The full script import os import json DB_DIR = \"ministry\" REPLACEMENTS = { \" (original mix)\" : \"\" , \" - \" : \" / \" , \"-\" : \" / \" , \" / \" : \"/\" } def parse_cd ( filename , replacements = None ): \"\"\" Takes the path to a FreeDB CD file and parses all key/value pairs into a dictionary. \"\"\" if replacements is None : replacements = {} lines = {} with open ( filename , \"r\" ) as f : for line in f . readlines (): # Remove newline chars line = line . rstrip () # Ignore any comments or lines without an equals in if \"=\" not in line or line . startswith ( \"#\" ): continue # Extract the keys and values, forcing the values to be # lower case eq_index = line . index ( \"=\" ) key = line [: eq_index ] value = line [ eq_index + 1 :] . lower () # Take a dictionary of strings to search and replace eg. # {\" (original mix)\": \"\", \" - \": \" / \"} for old , new in replacements . items (): value = value . replace ( old , new ) # Check for the existence of a partial line in the # dictionary first and then append the rest of the # value if it exists. if key in lines : lines [ key ] += value else : lines [ key ] = value return lines if __name__ == \"__main__\" : tracks_count = {} for filename in os . listdir ( DB_DIR ): # Parse the CD cd = parse_cd ( os . path . join ( DB_DIR , filename ), REPLACEMENTS ) # Extract the tracks tracks = [ cd [ x ] for x in cd . keys () if x . startswith ( \"TTITLE\" )] for track in tracks : # If the track has appeared already, increment its counter # otherwise add it and start it off at 1. if track in tracks_count : tracks_count [ track ] += 1 else : tracks_count [ track ] = 1 # Finally, sort the tracks_count dictionary by # amount of appearances for track_count in sorted ( tracks_count . items (), key = lambda x : x [ 1 ]): print \" %s : %s \" % track_count","tags":"Blog","title":"Ministry of Recycled Sound"}]}